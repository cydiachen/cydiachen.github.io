{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/03/26/4a17b156.html"},{"title":"Introduction","text":"从今天开始，本博客正式进行迁移，从原先的卡顿的博客目录迁移到最新的hexo框架下。","link":"/2020/03/26/ed318fdc.html"},{"title":"ant-man","text":"视频工具包——Ant Man: A tool for video processing on Python1. 需求2.开发进度表123456789gantttitle Ant Man: A tool for video processing on PythondateFormat 2020-04-03section 视频基本IO模块任务1 视频读取模块 :a1,2020-04-05, 5d任务2 视频输出模块 :a2, after a1 , 3d任务3 视频保存模块 :a3, after a2 , 3d任务4 视频缩放模块（插值实现） :a4,after a3 , 3d任务5 视频抽帧模块 :a5,after a4 , 3d 3. 功能测试表4. requirements mutliprocess; gc Opencv-python os","link":"/2020/04/03/4aba8923.html"},{"title":"opencv_video_ROI","text":"Python OpenCV 视频流处理之ROI的获取1、简介最近有接到一个案例，是要对视频进行分析检测的。但是由于现在能拿到的视频都是固定角度的，杂讯较多。要实现对视频有效的分析，需要手动先划定ROI，这里就涉及到了如何在Python中使用OpenCV对视频流进行处理，以及对ROI进行获取。 这里在OpenCV工具包中，有两种获取ROI的方法，一种是对图片提取ROI的方法，采用setMouseCallback的方法自己实现ROI的框选；另一种是直接调用函数selectROI进行获取。 这里首先看一下selectROIs的文档： Selects ROIs on the given image. Function creates a window and allows user to select a ROIs using mouse. Controls: use space or enter to finish current selection and start a new one, use esc to terminate multiple ROI selection process. void cv::selectROIs ( const String &amp; windowName, InputArray img, std::vector&lt; Rect &gt; &amp; boundingBoxes, bool showCrosshair = true, bool fromCenter = false ) Parameters windowNamename of the window where selection process will be shown. imgimage to select a ROI. boundingBoxesselected ROIs. showCrosshairif true crosshair of selection rectangle will be shown. fromCenterif true center of selection will match initial mouse position. In opposite case a corner of selection rectangle will correspont to the initial mouse position. The function sets it’s own mouse callback for specified window using cv::setMouseCallback(windowName, …). After finish of work an empty callback will be set for the used window. 这个函数的一个好处是直接给了一个返回值传出来，这也是我们任务需要的； 通过官方文档中的设置我们也可以看出，如果我们直接调用cv::setMouseCallback(windowName, …)自己来实现一个ROI的获取，没有办法把BBox的参数传出来；我这里自己使用了若干种方法，尝试在setMouseCallback方法中改变整个python代码的全局变量，但是发现这个方法仿佛是异步执行的，并不是立刻执行并改变值，也有可能是我没有调用正确。所以目前建议使用cv2.selectROI方法进行ROI区域的选取。","link":"/2020/04/04/546beffb.html"},{"title":"mmcv_intro","text":"MMCV源码解析（一）——总体简介1. 杂记今天放假，闲来无事，自己写视频的IO无聊了，正好有些思路比较凌乱，就大概商汤科技的MMLab公开的若干代码进行学习。其实在实际的生产环境中，纯粹的mmdetection由于其内部链接复杂，各种link都存在繁琐的关联关系，因而并不适合进行实际生产环境的魔改；相比之下，mmcv这个库包则更加合理，维护了若干CV任务中关键的过程，可以用来学习。 2. 文件夹结构简介.├── CONTRIBUTING.md├── Dockerfile├── LICENSE├── MANIFEST.in├── README.rst├── docs│ ├── Makefile│ ├── static│ │ ├── flow_img2toimg1.png│ │ ├── flow_raw_images.png│ │ ├── flow_visualization.png│ │ ├── flow_warp.png│ │ ├── flow_warp_diff.png│ │ ├── parallel_progress.gif│ │ └── progress.gif│ ├── api.rst│ ├── cnn.md│ ├── conf.py│ ├── image.md│ ├── index.rst│ ├── io.md│ ├── make.bat│ ├── runner.md│ ├── utils.md│ ├── video.md│ └── visualization.md├── examples│ ├── config_cifar10.py│ ├── dist_train_cifar10.sh│ ├── resnet_cifar.py│ └── train_cifar10.py├── mmcv│ ├── _init.py│ ├── arraymisc│ │ ├── init.py│ │ └── quantization.py│ ├── cnn│ │ ├── init.py│ │ ├── alexnet.py│ │ ├── resnet.py│ │ ├── vgg.py│ │ └── weight_init.py│ ├── fileio│ │ ├── init.py│ │ ├── handlers│ │ │ ├── init.py│ │ │ ├── base.py│ │ │ ├── json_handler.py│ │ │ ├── pickle_handler.py│ │ │ └── yaml_handler.py│ │ ├── io.py│ │ └── parse.py│ ├── image│ │ ├── init.py│ │ ├── colorspace.py│ │ ├── geometry.py│ │ ├── io.py│ │ ├── normalize.py│ │ └── resize.py│ ├── parallel│ │ ├── init.py│ │ ├── functions.py│ │ ├── collate.py│ │ ├── data_container.py│ │ ├── data_parallel.py│ │ ├── distributed.py│ │ ├── distributed_deprecated.py│ │ └── scatter_gather.py│ ├── runner│ │ ├── _init.py│ │ ├── checkpoint.py│ │ ├── dist_utils.py│ │ ├── hooks│ │ │ ├── init.py│ │ │ ├── checkpoint.py│ │ │ ├── closure.py│ │ │ ├── hook.py│ │ │ ├── iter_timer.py│ │ │ ├── logger│ │ │ │ ├── init.py│ │ │ │ ├── base.py│ │ │ │ ├── pavi.py│ │ │ │ ├── tensorboard.py│ │ │ │ ├── text.py│ │ │ │ └── wandb.py│ │ │ ├── lr_updater.py│ │ │ ├── memory.py│ │ │ ├── optimizer.py│ │ │ └── sampler_seed.py│ │ ├── log_buffer.py│ │ ├── parallel_test.py│ │ ├── priority.py│ │ ├── runner.py│ │ └── utils.py│ ├── utils│ │ ├── init.py│ │ ├── config.py│ │ ├── logging.py│ │ ├── misc.py│ │ ├── path.py│ │ ├── progressbar.py│ │ ├── registry.py│ │ └── timer.py│ ├── version.py│ ├── video│ │ ├── init.py│ │ ├── io.py│ │ ├── optflow.py│ │ ├── optflow_warp│ │ │ ├── init.py│ │ │ ├── flow_warp.cpp│ │ │ ├── flow_warp.hpp│ │ │ └── flow_warp_module.pyx│ │ └── processing.py│ └── visualization│ ├── init.py│ ├── color.py│ ├── image.py│ └── optflow.py├── requirements.txt├── setup.cfg├── setup.py└── tests ├── data │ ├── color.jpg │ ├── config │ │ ├── a.b.py │ │ ├── a.py │ │ ├── b.json │ │ ├── base.py │ │ ├── c.yaml │ │ ├── d.py │ │ ├── delete.py │ │ ├── e.py │ │ ├── f.py │ │ ├── l.py │ │ ├── l1.py │ │ ├── l2.yaml │ │ ├── l3.json │ │ ├── l4.py │ │ └── m.py │ ├── filelist.txt │ ├── for_scan │ │ ├── 1.json │ │ ├── 1.txt │ │ ├── 2.json │ │ ├── 2.txt │ │ ├── a.bin │ │ └── sub │ │ ├── 1.json │ │ └── 1.txt │ ├── grayscale.jpg │ ├── mapping.txt │ ├── optflow.flo │ ├── optflow_concat0.jpg │ ├── optflow_concat1.jpg │ ├── patches │ │ ├── 0.npy │ │ ├── 1.npy │ │ ├── 2.npy │ │ ├── 3.npy │ │ ├── 4.npy │ │ ├── pad0_0.npy │ │ ├── pad0_1.npy │ │ ├── pad0_2.npy │ │ ├── pad0_3.npy │ │ ├── pad0_4.npy │ │ ├── pad_0.npy │ │ ├── pad_1.npy │ │ ├── pad_2.npy │ │ ├── pad_3.npy │ │ ├── pad_4.npy │ │ ├── scale_0.npy │ │ ├── scale_1.npy │ │ ├── scale_2.npy │ │ ├── scale_3.npy │ │ └── scale_4.npy │ └── test.mp4 ├── test_arraymisc.py ├── test_config.py ├── test_fileio.py ├── test_hooks.py ├── test_image.py ├── test_logging.py ├── test_misc.py ├── test_optflow.py ├── test_path.py ├── test_progressbar.py ├── test_registry.py ├── test_runner.py ├── test_timer.py ├── test_video.py ├── test_visualization.py └── test_weight_init.py 主要文件夹结构看上去很复杂，但其实有不少文件，是专业的python deploy阶段才会出现的config类型文件。这里如果我们自己需要自研包，也需要进行对应的设计。 其中文件夹中最主要的是mmcv这个文件夹下的内容，这一系列的博文也针对这一系列的操作进行介绍。 mmcv文件夹下主要的文件目录包括： 1、arraymisc 这个文件夹下主要是保存了一些numpy的数组的数值操作，这些数值操作主要是用于数据的量化；主要的功能函数就两个：一个是负责对数组进行量化的quantize函数和一个对数组进行反量化的quantize函数。 这里是一个现阶段部署需要使用的方法，本文会进行一个相对比较系统的介绍。 2、cnn 这个文件夹下保存了一些商汤复现的简单CNN网络和一些简单的初始化方法，可以作为简单的CNN网络的入门。 这里不是本文的重点就不再赘述 3、fileio 这个文件夹下复现了若干简单的通用IO方法，比如load，dump以及json，pickle，yaml，从文件读list，从文件中读dict这些的handler。 本文会介绍他们进行IO的相关具体操作，以及对应的文件格式； 4、image 这个是整个项目的重头戏，相当于对OpenCV进行了二次封装，暴露了最终端的API以供直接调用得到结果。","link":"/2020/04/05/9a9c4b13.html"}],"tags":[{"name":"Introduction","slug":"Introduction","link":"/tags/Introduction/"},{"name":"python-tools","slug":"python-tools","link":"/tags/python-tools/"},{"name":"mmcv, toolkits","slug":"mmcv-toolkits","link":"/tags/mmcv-toolkits/"}],"categories":[]}